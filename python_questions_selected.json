{
    "Id": 70729502,
    "PostTypeId": 1,
    "Title": "F2 rename variable doesn't work in vscode + jupyter notebook + python",
    "Body": "I can use the normal F2 rename variable functionality in regular python files in vscode. But not when editing python in a jupyter notebook.\nWhen I press F2 on a variable in a jupyter notebook in vscode I get the familiar change variable window but when I press enter the variable is not changed and I get this error message:\n\nNo result. No result.\n\nIs there a way to get the F2 change variable functionality to work in jupyter notebooks?\nHere's my system info:\njupyter module version\n(adventofcode) C:\\git\\leetcode>pip show jupyter\nName: jupyter\nVersion: 1.0.0\nSummary: Jupyter metapackage. Install all the Jupyter components in one go.\nHome-page: http://jupyter.org\nAuthor: Jupyter Development Team\nAuthor-email: jupyter@googlegroups.org\nLicense: BSD\nLocation: c:\\users\\johan\\anaconda3\\envs\\adventofcode\\lib\\site-packages\nRequires: ipykernel, qtconsole, nbconvert, jupyter-console, notebook, ipywidgets\nRequired-by:\n\nPython version:\n(adventofcode) C:\\git\\leetcode>python --version\nPython 3.10.0\n\nvscode version:\n1.63.2 (user setup)\n\nvscode Jupyter extension version (from the changelog in the extensions window):\n2021.11.100 (November Release on 8 December 2021)\n\n",
    "AcceptedAnswerId": 70736000,
    "AcceptedAnswer": "Notice that you put up a bug report in GitHub and see this issue: Renaming variables didn't work, the programmer replied:\n\nSome language features are currently not supported in notebooks, but\nwe are making plans now to hopefully bring more of those online soon.\n\nSo please wait for this feature.\n"
}

{
    "Id": 70923969,
    "PostTypeId": 1,
    "Title": "how to remove the \"User-Agent\" header when send request in python",
    "Body": "I'm using python requests library, I need send a request without a user-agent header.\nI found this question, but it's for Urllib2.\nI'm trying to simulate an Android app which does this when calling a private API.\nI try to set User-Agent to None as in the following code, but it doesn't work. It still sends User-Agent: python-requests/2.27.1.\nIs there any way?\nheaders = requests.utils.default_headers()\nheaders['User-Agent'] = None\nrequests.post(url, *args, headers=headers, **kwargs)\n\n",
    "AcceptedAnswerId": 70924222,
    "AcceptedAnswer": "The requests library is built on top of the urllib3 library.  So, when you pass None User-Agent header to the requests's post method, the urllib3 set their own default User-Agent\nimport requests\n\nr = requests.post(\"https://httpbin.org/post\", headers={\n    \"User-Agent\": None,\n})\n\nprint(r.json()[\"headers\"][\"User-Agent\"])\n\nOutput\npython-urllib3/1.26.7\n\nHere the urllib3 source of connection.py\nclass HTTPConnection(_HTTPConnection, object):\n    ...\n\n    def request(self, method, url, body=None, headers=None):\n        if headers is None:\n            headers = {}\n        else:\n            # Avoid modifying the headers passed into .request()\n            headers = headers.copy()\n        if \"user-agent\" not in (six.ensure_str(k.lower()) for k in headers):\n            headers[\"User-Agent\"] = _get_default_user_agent()\n        super(HTTPConnection, self).request(method, url, body=body, headers=headers) \n\nSo, you can monkey patch it to disable default User-Agent header\nimport requests\nfrom urllib3 import connection\n\n\ndef request(self, method, url, body=None, headers=None):\n    if headers is None:\n        headers = {}\n    else:\n        # Avoid modifying the headers passed into .request()\n        headers = headers.copy()\n    super(connection.HTTPConnection, self).request(method, url, body=body, headers=headers)\n\nconnection.HTTPConnection.request = request\n\n\nr = requests.post(\"https://httpbin.org/post\", headers={\n    \"User-Agent\": None,\n})\n\nprint(r.json()[\"headers\"])\n\nOutput\n{\n'Accept': '*/*', \n'Accept-Encoding': 'gzip, deflate', \n'Content-Length': '0', \n'Host': 'httpbin.org', \n'X-Amzn-Trace-Id': 'Root=1-61f7b53b-26c4c8f6498c86a24ff05940'\n}\n\nAlso, consider to provide browser-like User-Agent like this Mozilla/5.0 (Macintosh; Intel Mac OS X 12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36. Maybe it solves your task with less effort\n"
}

{
    "Id": 71518406,
    "PostTypeId": 1,
    "Title": "How to bypass cloudflare browser checking selenium Python",
    "Body": "I am trying to access a site using selenium Python.\nBut the site is checking and checking continuously by cloudflare.\nNo other page is coming.\nCheck the screenshot here.\n\nI have tried undetected chrome but it is not working at all.\n",
    "AcceptedAnswerId": 71518481,
    "AcceptedAnswer": "By undetected chrome do you mean undetected chromedriver?:\nAnyways, undetected-chromedriver works for me:\nUndetected chromedriver\nGithub: https://github.com/ultrafunkamsterdam/undetected-chromedriver\npip install undetected-chromedriver\n\nCode that gets a cloudflare protected site:\nimport undetected_chromedriver as uc\ndriver = uc.Chrome(use_subprocess=True)\ndriver.get('https://nowsecure.nl')\n\nMy POV\n\n\n\nQuick setup code that logs into your google account:\nGithub: https://github.com/xtekky/google-login-bypass\nimport undetected_chromedriver as uc\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\n#  ---------- EDIT ----------\nemail = 'email\\n' # replace email\npassword = 'password\\n' # replace password\n#  ---------- EDIT ----------\n\ndriver = uc.Chrome(use_subprocess=True)\nwait = WebDriverWait(driver, 20)\nurl = 'https://accounts.google.com/ServiceLogin?service=accountsettings&continue=https://myaccount.google.com%3Futm_source%3Daccount-marketing-page%26utm_medium%3Dgo-to-account-button'\ndriver.get(url)\n\n\nwait.until(EC.visibility_of_element_located((By.NAME, 'identifier'))).send_keys(email)\nwait.until(EC.visibility_of_element_located((By.NAME, 'password'))).send_keys(password)\nprint(\"You're in!! enjoy\")\n\n# [ ---------- paste your code here ---------- ]\n\n"
}

{
    "Id": 71803409,
    "PostTypeId": 1,
    "Title": "VSCode: how to interrupt a running Python test?",
    "Body": "I'm using VSCode Test Explorer to run my Python unit tests. There was a bug in my code and my tested method never finishes.\nHow do I interrupt my test? I can't find how to do it using the GUI. I had to close VSCode to interrupt it.\nI'm using pytest framework.\n",
    "AcceptedAnswerId": 71803605,
    "AcceptedAnswer": "Silly me, here is the Stop button at the top right of the the Testing tab:\n\n"
}

{
    "Id": 72782100,
    "PostTypeId": 1,
    "Title": "For loop in c# vs For loop in python",
    "Body": "I was writing a method that would calculate the value of e^x. The way I implemented this in python was as follows.\nimport math\n\ndef exp(x):\n    return sum([\n        x**n/math.factorial(n)\n        for n in range(0, 100)\n    ])\n\nThis would return the value of e^x very well. But when I tried to implement the same method in c#, it didn't output the same value as it did in python. The following was the implementation in c#.\nstatic double exp(int x)\n{\n    double FinalAnswer = 0;\n    for (int j = 0; j <= 100; j++)\n    {\n        FinalAnswer += (Math.Pow(x, j))/Factorial(j);\n    }\n    return FinalAnswer;\n}\n\nThe output for this code was an infinity symbol at first. To resolve this I just reduced the number of times the loop ran. The output of the code in c# where the loop only ran 10 times was pretty close to the output in python where the loop ran 100 times. My question is that what is going on between the two loops in different programming languages. At first I thought that the expression that I was using in my method to calculate e^x was converging quickly. But how does a loop that runs 10 times produce an output that matches the output of a loop that runs 100 times.\nAlso, When I increased the for loop in c# to 20 and 30, the values of e^x for x > 3 were way off. Could someone explain what is going on here?\n",
    "AcceptedAnswerId": 72782395,
    "AcceptedAnswer": "What you're likely running into here is integer overflow with the C# version of the Factorial function (at least your implementation of it, or wherever its coming from).\nIn C#, an int is a numerical type stored in 32 bits of memory, which means it's bounded by -2^31  which is around +/- 2.1 billion. You could try using a long type, which is a 64 bit numerical type, however for even larger upper bounds in your for loop, like getting close to 100, you're going to overflow long as well.\nWhen you run the Factorial function in C#, it starts off normally for the first little while, however if you keep going, you'll see that it all of a sudden jumps into negative numbers, and if you keep going even further than that, it'll get to 0 and stop changing. You're seeing the output of infinity due to division by 0, and C# has a way of handling that with doubles; that being to just return double.PositiveInfinity.\nThe reason why this doesn't happen in python is that it uses a variable number of bits to store its numerical values.\nAdded note: What you might also want to try is using a Factorial function that works with the double type instead of int or long, however by doing this, you'll lose precision on what the exact value is, but you get more range as the magnitude of the number you can store is larger\nFurther Note: As mentioned in the comments, C# has a type called BigInteger which is designed to handle huge numbers like the values you would expect from large inputs to a Factorial function. You can find a reference to the BigInteger docs here\n\nWhat you can do is calculate each component of the factorial function separately with the power you're using. Here's what I mean:\npublic decimal Exp(decimal power, int accuracy = 100)\n{\n    decimal runningTotal = 1;\n    decimal finalValue = 1;\n    for (int i = 1; i <= accuracy; i++)\n    {\n        runningTotal *= power/i;\n        finalValue += runningTotal;\n    }\n    return finalValue;\n}\n\n"
}

{
    "Id": 73271404,
    "PostTypeId": 1,
    "Title": "How to find the average of the differences between all the numbers of a Python List",
    "Body": "I have a python list like this,\narr = [110, 60, 30, 10, 5] \n\nWhat I need to do is actually find the difference of every number with all the other numbers and then find the average of all those differences.\nSo, for this case, it would first find the difference between 110 and then all the remaining elements, i.e. 60, 30, 10, 5, and then it will find the difference of 60 with the remaining elements, i.e. 30, 10, 5 and etc.\nAfter which, it will compute the Average of all these differences.\nNow, this can easily be done with two For Loops but in O(n^2) time complexity and also a little bit of \"messy\" code. I was wondering if there was a faster and more efficient way of doing this same thing?\n",
    "AcceptedAnswerId": 73271447,
    "AcceptedAnswer": "I'll just give the formula first:\nn = len(arr)\nout = np.sum(arr * np.arange(n-1, -n, -2) ) / (n*(n-1) / 2)\n# 52\n\nExplanation: You want to find the mean of\na[0] - a[1], a[0] - a[2],..., a[0] - a[n-1]\n             a[1] - a[2],..., a[1] - a[n-1]\n                         ...\n\nthere, your\n`a[0]` occurs `n-1` times with `+` sign, `0` with `-` -> `n-1` times\n`a[1]` occurs `n-2` times with `+` sign, `1` with `-` -> `n-3` times\n... and so on \n\n"
}

{
    "Id": 74605279,
    "PostTypeId": 1,
    "Title": "Python 3.11 worse optimized than 3.10?",
    "Body": "I run this simple loop with Python 3.10.7 and 3.11.0 on Windows 10.\nimport time\na = 'a'\n\nstart = time.time()\nfor _ in range(1000000):\n    a += 'a'\nend = time.time()\n\nprint(a[:5], (end-start) * 1000)\n\nThe older version executes in 187ms, Python 3.11 needs about 17000ms. Does 3.10 realize that only the first 5 chars of a are needed, whereas 3.11 executes the whole loop? I confirmed this performance difference on godbolt.\n",
    "AcceptedAnswerId": 74607850,
    "AcceptedAnswer": "TL;DR: you should not use such a loop in any performance critical code but ''.join instead. The inefficient execution appears to be related to a regression during the bytecode generation in CPython 3.11 (and missing optimizations during the evaluation of binary add operation on Unicode strings).\n\nGeneral guidelines\nThis is an antipattern. You should not write such a code if you want this to be fast. This is described in PEP-8:\n\nCode should be written in a way that does not disadvantage other implementations of Python (PyPy, Jython, IronPython, Cython, Psyco, and such). \nFor example, do not rely on CPython\u2019s efficient implementation of in-place string concatenation for statements in the form a += b or a = a + b. This optimization is fragile even in CPython (it only works for some types) and isn\u2019t present at all in implementations that don\u2019t use refcounting. In performance sensitive parts of the library, the ''.join() form should be used instead. This will ensure that concatenation occurs in linear time across various implementations.\n\nIndeed, other implementations like PyPy does not perform an efficient in-place string concatenation for example. A new bigger string is created for every iteration (since strings are immutable, the previous one may be referenced and PyPy does not use a reference counting but a garbage collector). This results in a quadratic runtime as opposed to a linear runtime in CPython (at least in past implementation).\n\nDeep Analysis\nI can reproduce the problem on Windows 10 between the embedded (64-bit x86-64) version of CPython 3.10.8 and the one of 3.11.0:\nTimings:\n - CPython 3.10.8:    146.4 ms\n - CPython 3.11.0:  15186.8 ms\n\nIt turns out the code has not particularly changed between CPython 3.10 and 3.11 when it comes to Unicode string appending. See for example PyUnicode_Append: 3.10 and 3.11.\nA low-level profiling analysis shows that nearly all the time is spent in one unnamed function call of another unnamed function called by PyUnicode_Concat (which is also left unmodified between CPython 3.10.8 and 3.11.0). This slow unnamed function contains a pretty small set of assembly instructions and nearly all the time is spent in one unique x86-64 assembly instruction: rep movsb byte ptr [rdi], byte ptr [rsi]. This instruction is basically meant to copy a buffer pointed by the rsi register to a buffer pointed by the rdi register (the processor copy rcx bytes for the source buffer to the destination buffer and decrement the rcx register for each byte until it reach 0). This information shows that the unnamed function is actually memcpy of the standard MSVC C runtime (ie. CRT) which appears to be called by _copy_characters itself called by _PyUnicode_FastCopyCharacters of PyUnicode_Concat (all the functions are still belonging to the same file). However, these CPython functions are still left unmodified between CPython 3.10.8 and 3.11.0. The non-negligible time spent in malloc/free (about 0.3 seconds) seems to indicate that a lot of new string objects are created -- certainly at least 1 per iteration -- matching with the call to PyUnicode_New in the code of PyUnicode_Concat. All of this indicates that a new bigger string is created and copied as specified above.\nThe thing is calling PyUnicode_Concat is certainly the root of the performance issue here and I think CPython 3.10.8 is faster because it certainly calls PyUnicode_Append instead. Both calls are directly performed by the main big interpreter evaluation loop and this loop is driven by the generated bytecode.\nIt turns out that the generated bytecode is different between the two version and it is the root of the performance issue. Indeed, CPython 3.10 generates an INPLACE_ADD bytecode instruction while CPython 3.11 generates a  BINARY_OP bytecode instruction. Here is the bytecode for the loops in the two versions:\nCPython 3.10 loop:\n\n        >>   28 FOR_ITER                 6 (to 42)\n             30 STORE_NAME               4 (_)\n  6          32 LOAD_NAME                1 (a)\n             34 LOAD_CONST               2 ('a')\n             36 INPLACE_ADD                             <----------\n             38 STORE_NAME               1 (a)\n             40 JUMP_ABSOLUTE           14 (to 28)\n\nCPython 3.11 loop:\n\n        >>   66 FOR_ITER                 7 (to 82)\n             68 STORE_NAME               4 (_)\n  6          70 LOAD_NAME                1 (a)\n             72 LOAD_CONST               2 ('a')\n             74 BINARY_OP               13 (+=)         <----------\n             78 STORE_NAME               1 (a)\n             80 JUMP_BACKWARD            8 (to 66)\n\nThis changes appears to come from this issue. The code of the main interpreter loop (see ceval.c) is different between the two CPython version. Here are the code executed by the two versions:\n        // In CPython 3.10.8\n        case TARGET(INPLACE_ADD): {\n            PyObject *right = POP();\n            PyObject *left = TOP();\n            PyObject *sum;\n            if (PyUnicode_CheckExact(left) && PyUnicode_CheckExact(right)) {\n                sum = unicode_concatenate(tstate, left, right, f, next_instr); // <-----\n                /* unicode_concatenate consumed the ref to left */\n            }\n            else {\n                sum = PyNumber_InPlaceAdd(left, right);\n                Py_DECREF(left);\n            }\n            Py_DECREF(right);\n            SET_TOP(sum);\n            if (sum == NULL)\n                goto error;\n            DISPATCH();\n        }\n\n//----------------------------------------------------------------------------\n\n        // In CPython 3.11.0\n        TARGET(BINARY_OP_ADD_UNICODE) {\n            assert(cframe.use_tracing == 0);\n            PyObject *left = SECOND();\n            PyObject *right = TOP();\n            DEOPT_IF(!PyUnicode_CheckExact(left), BINARY_OP);\n            DEOPT_IF(Py_TYPE(right) != Py_TYPE(left), BINARY_OP);\n            STAT_INC(BINARY_OP, hit);\n            PyObject *res = PyUnicode_Concat(left, right); // <-----\n            STACK_SHRINK(1);\n            SET_TOP(res);\n            _Py_DECREF_SPECIALIZED(left, _PyUnicode_ExactDealloc);\n            _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);\n            if (TOP() == NULL) {\n                goto error;\n            }\n            JUMPBY(INLINE_CACHE_ENTRIES_BINARY_OP);\n            DISPATCH();\n        }\n\nNote that unicode_concatenate calls PyUnicode_Append (and do some reference counting checks before). In the end, CPython 3.10.8 calls PyUnicode_Append which is fast (in-place) and CPython 3.11.0 calls PyUnicode_Concat which is slow (out-of-place). It clearly looks like a regression to me.\nPeople in the comments reported having no performance issue on Linux. However, experimental tests shows a BINARY_OP instruction is also generated on Linux, and I cannot find so far any Linux-specific optimization regarding string concatenation. Thus, the difference between the platforms is pretty surprising.\n\nUpdate: towards a fix\nI have opened an issue about this available here. One should not that putting the code in a function is significantly faster due to the variable being local (as pointed out by @Dennis in the comments).\n\nRelated posts:\n\nHow slow is Python's string concatenation vs. str.join?\nPython string 'join' is faster (?) than '+', but what's wrong here?\nPython string concatenation in for-loop in-place?\n\n"
}

{
    "Id": 74583630,
    "PostTypeId": 1,
    "Title": "Why is Python saying modules are imported when they are not?",
    "Body": "Python 3.6.5\nUsing this answer as a guide, I attempted to see whether some modules, such as math were imported.\nBut Python tells me they are all imported when they are not.\n>>> import sys\n>>> 'math' in sys.modules\nTrue\n>>> 'math' not in sys.modules\nFalse\n>>> math.pi\nTraceback (most recent call last):\n  File \"\", line 1, in \nNameError: name 'math' is not defined\n>>> import math\n>>> 'math' in sys.modules\nTrue\n>>> math.pi\n3.141592653589793\n\n",
    "AcceptedAnswerId": 74583684,
    "AcceptedAnswer": "to explain this, let's define this function:\ndef import_math():\n    import math\n\nimport_math()\n\nthe above function will import the module math, but only in its local scope, anyone that tries to reference math outside of it will get a name error, because math is not defined in the global scope.\nany module that is imported is saved into sys.modules so a call to check\nimport_math()\nprint(\"math\" in sys.modules)\n\nwill print True, because sys.modules caches any module that is loaded anywhere, whether or not it was available in the global scope, a very simple way to define math in the global scope would then to\nimport_math()\nmath = sys.modules[\"math\"]\n\nwhich will convert it from being only in sys.modules to being in the global scope, this is just equivalent to\nimport math\n\nwhich defines a variable math in the global scope that points to the module math.\nnow if you want to see whether \"math\" exists in the global scope is to check if it is in the global scope directly.\nprint(\"math\" in globals())\nprint(\"math\" in locals())\n\nwhich will print false if \"math\" wasn't imported into the global or local scope and is therefore inaccessable.\n"
}

{
    "Id": 71671866,
    "PostTypeId": 1,
    "Title": "Python: What is the difference between `lambda` and `lambda_`?",
    "Body": "I know the function of lambda: and lambda var: , but what does lambda_: means acutally?\n",
    "AcceptedAnswerId": 71671890,
    "AcceptedAnswer": "lambda_ is just a variable name, like any other. Like foo or x.\nIf you saw:\nlambda_: Something\n\nThen that is actually a variable annotation, for type hints, so the same as:\nnum: int\nnum = 0\n\n"
}

{
    "Id": 74599713,
    "PostTypeId": 1,
    "Title": "Merge two dictionaries in python",
    "Body": "I'm trying to merge two dictionaries based on key value. However, I'm not able to achieve it. Below is the way I tried solving.\ndict1 = {4: [741, 114, 306, 70],\n         2: [77, 325, 505, 144],\n         3: [937, 339, 612, 100],\n         1: [52, 811, 1593, 350]}\ndict2 = {1: 'A', 2: 'B', 3: 'C', 4: 'D'}\n\nMy resultant dictionary should be\noutput = {'D': [741, 114, 306, 70],\n          'B': [77, 325, 505, 144],\n          'C': [937, 339, 612, 100],\n          'A': [52, 811, 1593, 350]}\n\nMy code\ndef mergeDictionary(dict_obj1, dict_obj2):\n    dict_obj3 = {**dict_obj1, **dict_obj2}\n    for key, value in dict_obj3.items():\n        if key in dict_obj1 and key in dict_obj2:\n               dict_obj3[key] = [value , dict_obj1[key]]\n    return dict_obj3\n\ndict_3 = mergeDictionary(dict1, dict2)\n\nBut I'm getting this as output\ndict_3={4: ['D', [741, 114, 306, 70]], 2: ['B', [77, 325, 505, 144]], 3: ['C', [937, 339, 612, 100]], 1: ['A', [52, 811, 1593, 350]]}\n\n",
    "AcceptedAnswerId": 74599751,
    "AcceptedAnswer": "Use a simple dictionary comprehension:\noutput = {dict2[k]: v for k,v in dict1.items()}\n\nOutput:\n{'D': [741, 114, 306, 70],\n 'B': [77, 325, 505, 144],\n 'C': [937, 339, 612, 100],\n 'A': [52, 811, 1593, 350]}\n\n"
}